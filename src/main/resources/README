Запуск программы:

Перейти в каталог target/classes
запустить
testDemo.cmd
После запуска программы на экран будет выводится номер сообщения, полученный от диспетчера,
номер исполнителя, и имя потока клиента.


скрипт clearFolders.cmd
очищает папки от сообщений

Можно запускать прототип и под linux
(запускаемые скрипты имеют расширение .sh, перед этим выполнив команду chmod +x ./*.sh,
 для возможности запуска скриптов)

Архитектура простая:
Для каждой сущности существует свой класс
Класс Client  (Клиент)
Класс Dispatcher (Диспетчер)
Класс Executor (Исполнитель)

Создается 100 потоков для каждого клиента.
Каждый клиент обращается к диспетчеру, который в системе один (Шаблон одиночка)
Диспетчер распределяет задания для каждого исполнителя
(10 исполнителей, и для сохранения каждого сообщение создается свой поток...)
Исполнитель сохраняет xml файл и ждёт три секунты

Так как это тестовое приложение, то оно может служить прототипов для реальных приложений и
с помощью прототипа можно обсудить и заложить архитектуру создаваемого приложения.

В прототипе использовался простой подход:
Один процес на всё приложение и каждая сущность порождает свой поток.

В реальном приложении каждая сущность может быть реализована в своём процессе, как, например Диспетчер,
Клиент или Исполнитель и тогда будет задействован меж-процессорный обмен, например,
по какому-нибудь сетевому протоколу.

И реальное приложение можно уже разработывать с использованием таких технологий как WebService...
Для хранения данных можно уже подключать базы данных (технология Hibernate или JPA) и так далее.

И желательно разработать объектную модель предметной области приложения, хотя бы на основе прототипа...

Узким местом в прототипе является диспетчер, так как он один обрабатывает все запросы...
(Во второй версии прототипа диспетчер отрабатывает сразу и уже как бы не является узким местом,
потому что его код метода "sendMessage" не ждёт завершения исполнителя, а отдаёт это задачу самому исполнтителю...)

В реальном приложении можно диспетчер сделать из нескольких потоков,
работающем в собственном процессе (например в виде сервлета или веб-службы),
чтобы приложение было бы масштабируемым...
Но скорости это реальному приложению не добавит, так как межпроцессорный обмен на порядок медленнее,
чем обмен даннымм в одном процессе для нескольких потоков...














